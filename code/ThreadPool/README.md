## 线程池
[参考 Chunel Feng 大佬实现的线程池](https://github.com/ChunelFeng/CThreadPool)，相对于普通线程池（生产者-消费者模型）做了以下优化

1. `local-thread` 机制 :针对多个`thread`去【争抢】`threadPool`中任务队列中的第一个`task`要加锁操作带来的性能开销，把原先`threadPool`的`queue`中的任务，放到不同的`N`个线程私有的`queue`中，线程执行任务的时候就不需要再从`threadPool`中获取去【争抢】。本项目自己设计的任务分配策略是，将任务轮流放到`N`个线程自己的`queue`中，但是当线程自己的队列任务超过一定数量之后，则把任务放到公共线程池中，减少该线程的负担。

2. `lock-free`机制：基于`atomic`的、基于内部封装`mutex`的、基于`cas`机制的。这里原作者是通过内部加入`mutex`和`condition_variable`来进行控制，本项目基于 `atomic` 实现的自旋锁进行队列任务存取。个人认为针对于任务密集型，采用自旋锁进行任务的放取会好些，因为线程一直在运行，不用等待条件唤醒；对于少量任务时，互斥锁+条件变量更合适，因为自旋锁，判断是否有任务时加/解锁次数会更多。

3. 自动扩缩容机制: 增加`MonitorThread`监控线程，在主线程全部任务繁忙的时候，threadPool中多加入几个辅助线程；而在清闲的时候，对辅助线程进行自动回收。监控线程每隔一定时间检查主线程和辅助线程的运行情况。


- 2023.4.13 修改  
    * 当主线程自身任务队列和公共任务队列都为空的时候，阻塞该线程，直到添加了新任务才唤醒
    * 辅助线程当自身任务队列和公共任务队列都为空的时候，就让出(yield) CPU 小段时间然后接着判断是否有任务，因为出现了辅助线程了，肯定当前请求量较多 
    * 从公共任务队列取任务，采取批量取的方式，减少线程之间的争抢任务加锁的次数